---
layout:     post
title:      "HashMap原理"
subtitle:   ""
date:       2019-05-11 12:00:00
author:     "xuefei"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - java
---
## 概述
作为哈希表的Map接口实现，其具备以下几个特点

+ 允许key和value值为null
+ 跟HashTable相比较，除了不是线程安全的，其他地方大致相同
+ 在实现方面采用数组+单链表的形式存储元素，当不同元素的hash值发生时，通过单链表的形式存储。为了解决链表查询效率的问题，在单链表中的元素超过指定阀值时，将转换为红黑树存储结构。
+ 在构建HashMap实例时有两个重要的参数会影响其性能：初始化大小和加载因子。初始化大小用来规定哈希表数组的长度。加载因子用来表示哈希表元素的填满程度，越大则表示允许填充的元素就越多，哈希表的利用空间就越高，但是冲突的几率也就增高了。反之，越小则冲突的机会就越少，但是空间很多就浪费了。

## 源码分析
### 静态常量
```java
    /**
     * 默认初始化大小 - 必须为2的幂.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

    /**
     * 最大容量，必须不大于2^30
     */
    static final int MAXIMUM_CAPACITY = 1 << 30;

    /**
     * 默认加载因子，值为0.75
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * hash冲突默认采用单链表存储，当单链表节点个数大雨8时，会转化为红黑树存储
     */
    static final int TREEIFY_THRESHOLD = 8;

    /**
     * 在删除元素的过程中，当红黑树中的元素少于6时，则转换为单链表
     */
    static final int UNTREEIFY_THRESHOLD = 6;

    /**
     * 将单链表转换为红黑出存储的前提是：只有在数组长度大于64时才转换
     */
    static final int MIN_TREEIFY_CAPACITY = 64;
```