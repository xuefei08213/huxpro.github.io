---
layout:     post
title:      "HashMap原理"
subtitle:   ""
date:       2019-05-11 12:00:00
author:     "xuefei"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - java
---
## 概述
作为哈希表的Map接口实现，其具备以下几个特点

+ 允许key和value值为null
+ 跟HashTable相比较，除了不是线程安全的，其他地方大致相同
+ 在实现方面采用数组+单链表的形式存储元素，当不同元素的hash值发生时，通过单链表的形式存储。为了解决链表查询效率的问题，在单链表中的元素超过指定阀值时，将转换为红黑树存储结构。
+ 在构建HashMap实例时有两个重要的参数会影响其性能：初始化大小和加载因子。初始化大小用来规定哈希表数组的长度。加载因子用来表示哈希表元素的填满程度，越大则表示允许填充的元素就越多，哈希表的利用空间就越高，但是冲突的几率也就增高了。反之，越小则冲突的机会就越少，但是空间很多就浪费了。

## 源码分析
### 静态常量
```java
    /**
     * 默认初始化大小 - 必须为2的幂.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

    /**
     * 最大容量，必须不大于2^30
     */
    static final int MAXIMUM_CAPACITY = 1 << 30;

    /**
     * 默认加载因子，值为0.75
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * hash冲突默认采用单链表存储，当单链表节点个数大雨8时，会转化为红黑树存储
     */
    static final int TREEIFY_THRESHOLD = 8;

    /**
     * 在删除元素的过程中，当红黑树中的元素少于6时，则转换为单链表
     */
    static final int UNTREEIFY_THRESHOLD = 6;

    /**
     * 将单链表转换为红黑出存储的前提是：只有在数组长度大于64时才转换
     */
    static final int MIN_TREEIFY_CAPACITY = 64;
```

### 指定初始容量构造函数
```java
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
    
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
    
    /**
     * 返回大于等于cap的最小的2的幂
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```

上面的方法中有一个tableSizeFor的方法，它的目的是将构造函数中容量的转换为大于等于它的最小的2的幂，如果容量为12，那么返回的值为16，**那为什么数组的容量必须是2的幂呢？**

因为索引计算公式为i = (n-1) & hash，如果n为2次幂，那么n-1的低位就全是1，哈希值进行与操作时可以保证低位的值不变，从而保证分布均匀，效果等同于hash%n，但是位运算比取余运算要高效的多。

